<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>MySQL range partition VS range columns partition &#8211; MINSQL</title>
<meta name="description" content="MySQL range partition VS range columns partition

">
<meta name="keywords" content="MySQL">


<!-- Twitter Cards -->
<meta name="twitter:title" content="MySQL range partition VS range columns partition">
<meta name="twitter:description" content="MySQL range partition VS range columns partition

">



<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:4000/images/mysql.png">

<!-- Open Graph -->
<meta property="og:locale" content="ko_KR">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL range partition VS range columns partition">
<meta property="og:description" content="MySQL range partition VS range columns partition

">
<meta property="og:url" content="http://localhost:4000/blog/mysql-range-partition-vs-range-columns-partition/">
<meta property="og:site_name" content="MINSQL">





<link rel="canonical" href="http://localhost:4000/blog/mysql-range-partition-vs-range-columns-partition/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="MINSQL Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.css">
<!-- Webfonts -->
<script src="https://use.edgefonts.net/source-sans-pro:n2,i2,n3,i3,n4,i4,n6,i6,n7,i7,n9,i9;source-code-pro:n4,n7;volkhov.js"></script>

<meta http-equiv="cleartype" content="on">

<!-- HTML5 Shiv and Media Query Support -->
<!--[if lt IE 9]>
  <script src="http://localhost:4000/assets/js/vendor/html5shiv.min.js"></script>
  <script src="http://localhost:4000/assets/js/vendor/respond.min.js"></script>
<![endif]-->

<!-- Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.7.1.custom.min.js"></script>


<!-- MathJax -->
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.png">

</head>

<body id="post">

<div class="navigation-wrapper">
	<nav role="navigation" id="site-nav" class="animated drop">
	    <ul>
      
		    
		    <li><a href="http://localhost:4000/about/" >About</a></li>
		  
		    
		    <li><a href="http://localhost:4000/blog/" >Blog</a></li>
		  
		    
		    <li><a href="http://localhost:4000/tags/" >Tags</a></li>
		  
		    
		    <li><a href="http://localhost:4000/search/" >Search</a></li>
		  
	    </ul>
	</nav>
</div><!-- /.navigation-wrapper -->

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->


<div class="js-menu-screen menu-screen"></div>


<div id="main" role="main">
  <article class="entry">
    
  <!--  <img src="http://localhost:4000/images/mysql.png" class="entry-feature-image" alt="MySQL range partition VS range columns partition" >-->
    <div class="entry-wrapper">
      <header class="entry-header">
        <ul class="entry-tags">
          <li><a href="http://localhost:4000/tags/#MySQL" title="Pages tagged MySQL">MySQL</a></li>
        </ul>
        
          <h1 class="entry-title">MySQL range partition VS range columns partition</h1>
        
      </header>
      <footer class="entry-meta">
        
        
          <img src="http://localhost:4000/images/makayal-photo.jpg" class="bio-photo" alt="MIN CHO bio photo"/>
        
        <span class="author vcard">By <span class="fn">MIN CHO</span></span>
        <span class="entry-date date published"><time datetime="2018-01-22T14:46:49+09:00"><i class="fa fa-calendar-o"></i> January 22, 2018</time></span>
        
        <span class="entry-comments"><i class="fa fa-comment-o"></i> <a href="#disqus_thread">Comment</a></span>
        
        

        

          <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-cog"></i> My Table of Contents</h4></header>
              <ul class="toc__menu">
  <li><a href="#개요">개요</a></li>
  <li><a href="#생성방법">생성방법</a></li>
  <li><a href="#장단점">장단점</a></li>
  <li><a href="#결론">결론</a></li>
</ul>
            </nav>

        
      </footer>
      <div class="entry-content">
        <h1 id="mysql-range-partition-vs-range-columns-partition">MySQL range partition VS range columns partition</h1>

<p>날짜를 이용하여 파티션시, range 를 사용할 것인가? range colums 를 사용할 것인가?</p>

<h3 id="개요">개요</h3>

<ul>
  <li>데이터가 커짐에 따라, mysql 에서도 partition 기능을 많이 사용하게 된다. 특히 날짜를 이용하여, partitioning 을 많이 진행하게 되는데 이는 “PARTITION BY RANGE (to_days(날짜형식컬럼))” 혹은 “ PARTITION BY RANGE COLUMNS(날짜형식컬럼))” 으로 진행될 수 있다. 이 두형식에 대해 알아보자.</li>
</ul>

<h3 id="생성방법">생성방법</h3>

<ul>
  <li>RANGE PARTITONING
    <ul>
      <li>대부분의 MySQL DBA 들은 날짜를 이용하여 파티션시, range 를 자주 사용한다. 사용은 date 형 컬럼을 to_days 로 비교하여 사용될 수 있다. (Range 파티션은 값으로 int 형 데이터가 와야 하기 때문이다.</li>
    </ul>
  </li>
</ul>

<div class="language-sql highlighter-rouge"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">pt_range</span> <span class="p">(</span>
  <span class="n">id</span> <span class="n">int</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
  <span class="n">some_data</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span>
  <span class="n">createdAt</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">modifiedAt</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span><span class="n">createdAt</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="n">AUTO_INCREMENT</span><span class="o">=</span><span class="mi">1</span> <span class="k">DEFAULT</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">utf8</span>
<span class="n">partition</span> <span class="k">by</span> <span class="n">range</span> <span class="p">(</span><span class="n">to_days</span><span class="p">(</span><span class="n">createdAt</span><span class="p">))</span>
<span class="p">(</span>
<span class="n">partition</span> <span class="n">p201801</span> <span class="k">values</span> <span class="k">less</span> <span class="k">than</span> <span class="p">(</span><span class="n">to_days</span><span class="p">(</span><span class="s1">'2018-02-01'</span><span class="p">)),</span>
<span class="n">partition</span> <span class="n">p201802</span> <span class="k">values</span> <span class="k">less</span> <span class="k">than</span> <span class="p">(</span><span class="n">to_days</span><span class="p">(</span><span class="s1">'2018-03-01'</span><span class="p">)),</span>
<span class="n">partition</span> <span class="n">p201803</span> <span class="k">values</span> <span class="k">less</span> <span class="k">than</span> <span class="p">(</span><span class="n">to_days</span><span class="p">(</span><span class="s1">'2018-04-01'</span><span class="p">)),</span>
<span class="n">partition</span> <span class="n">p201804</span> <span class="k">values</span> <span class="k">less</span> <span class="k">than</span> <span class="p">(</span><span class="n">to_days</span><span class="p">(</span><span class="s1">'2018-05-01'</span><span class="p">)),</span>
<span class="n">partition</span> <span class="n">p201805</span> <span class="k">values</span> <span class="k">less</span> <span class="k">than</span> <span class="p">(</span><span class="n">to_days</span><span class="p">(</span><span class="s1">'2018-06-01'</span><span class="p">)),</span>
<span class="n">partition</span> <span class="n">p201806</span> <span class="k">values</span> <span class="k">less</span> <span class="k">than</span> <span class="p">(</span><span class="n">to_days</span><span class="p">(</span><span class="s1">'2018-07-01'</span><span class="p">))</span>
<span class="p">);</span>
</code></pre>
</div>

<p><a href="https://dev.mysql.com/doc/refman/5.7/en/partitioning-range.html">https://dev.mysql.com/doc/refman/5.7/en/partitioning-range.html</a></p>

<ul>
  <li>RANGE COLUMNS PARTITONING
    <ul>
      <li>파티션은 잘 모르는분들도 있겠지만, range partition 과 비슷하지만 복합 컬럼을 사용할 수 있다는 장점이 있다. 이는 열거된 컬럼들과 row 의 실제값과의 비교연산을 통해 partition 이 선택이 되는데, 날짜 형식컬럼을 partition key 로 지정하여 비교를 진행할 수 있다.</li>
    </ul>
  </li>
</ul>

<div class="language-sql highlighter-rouge"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">pt_range_columns</span> <span class="p">(</span>
  <span class="n">id</span> <span class="n">int</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
  <span class="n">some_data</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span>
  <span class="n">createdAt</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">modifiedAt</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span><span class="n">createdAt</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="n">AUTO_INCREMENT</span><span class="o">=</span><span class="mi">1</span> <span class="k">DEFAULT</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">utf8</span>
<span class="n">PARTITION</span> <span class="k">BY</span> <span class="n">RANGE</span> <span class="n">COLUMNS</span><span class="p">(</span><span class="n">createdAt</span><span class="p">)</span>
<span class="p">(</span>
<span class="n">PARTITION</span> <span class="n">p201801</span> <span class="k">VALUES</span> <span class="k">LESS</span> <span class="k">THAN</span> <span class="p">(</span><span class="s1">'2018-02-01'</span><span class="p">)</span> <span class="n">ENGINE</span> <span class="o">=</span> <span class="n">InnoDB</span><span class="p">,</span>
 <span class="n">PARTITION</span> <span class="n">p201802</span> <span class="k">VALUES</span> <span class="k">LESS</span> <span class="k">THAN</span> <span class="p">(</span><span class="s1">'2018-03-01'</span><span class="p">)</span> <span class="n">ENGINE</span> <span class="o">=</span> <span class="n">InnoDB</span><span class="p">,</span>
 <span class="n">PARTITION</span> <span class="n">p201803</span> <span class="k">VALUES</span> <span class="k">LESS</span> <span class="k">THAN</span> <span class="p">(</span><span class="s1">'2018-04-01'</span><span class="p">)</span> <span class="n">ENGINE</span> <span class="o">=</span> <span class="n">InnoDB</span><span class="p">,</span>
 <span class="n">PARTITION</span> <span class="n">p201804</span> <span class="k">VALUES</span> <span class="k">LESS</span> <span class="k">THAN</span> <span class="p">(</span><span class="s1">'2018-05-01'</span><span class="p">)</span> <span class="n">ENGINE</span> <span class="o">=</span> <span class="n">InnoDB</span><span class="p">,</span>
 <span class="n">PARTITION</span> <span class="n">p201805</span> <span class="k">VALUES</span> <span class="k">LESS</span> <span class="k">THAN</span> <span class="p">(</span><span class="s1">'2018-06-01'</span><span class="p">)</span> <span class="n">ENGINE</span> <span class="o">=</span> <span class="n">InnoDB</span><span class="p">,</span>
 <span class="n">PARTITION</span> <span class="n">p201806</span> <span class="k">VALUES</span> <span class="k">LESS</span> <span class="k">THAN</span> <span class="p">(</span><span class="s1">'2018-07-01'</span><span class="p">)</span> <span class="n">ENGINE</span> <span class="o">=</span> <span class="n">InnoDB</span><span class="p">);</span>
</code></pre>
</div>

<p><a href="https://dev.mysql.com/doc/refman/5.7/en/partitioning-columns-range.html">https://dev.mysql.com/doc/refman/5.7/en/partitioning-columns-range.html</a></p>

<h3 id="장단점">장단점</h3>

<h4 id="1-성능-관점에서">1. 성능 관점에서</h4>

<ul>
  <li>일반적으로 성능상에는 아주 미세하게 “RANGE (to_days(createdAt))” 가 빠르다. date 형 값을 to_days function 으로 int 로 바꾸어 지정된 partition 으로 들어갈 수 있도록 비교하는것이, date 형을 string 형으로 바꾼 후 string 형으로 비교하는것보다 미세하게 빠르기 때문이다. 물론 CPU 의 성능에 따라 다르겠지만, 위와같은 비교연산에 비해 나머지 연산들 (Data 를 변경하거나 SELECT 하는 연산들) 이 훨씬 더 많은 자원과 시간을 소모하기때문에 크게 문제가 되지는 않는다. 이는 큰 문제가 되지 않는다.</li>
</ul>

<blockquote>
  <p>성능을 측정하기 위해 mysqlslap 을 이용하여, 단순 TEST를 진행해보자. 천건씩 (limit 1000) insert 를 10개의 세션 (–concurrency=10) 에서 모두 1000 번 (–number-of-queries=1000, 세션당 100번) 을 실행한다. 이를 10번 진행해보고 (–iterations=10) 결과를 확인해보자.</p>
</blockquote>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>root@localhost msb_5_7_19]# cat bt.sh
<span class="nb">echo</span> <span class="s2">"========================================================"</span>
<span class="nb">echo</span> <span class="s2">"Test for insert on range partition table"</span>
date
/MySQL_bianries/5.7.19/bin/mysqlslap  --concurrency<span class="o">=</span>10 --create-schema<span class="o">=</span><span class="nb">test</span> --iterations<span class="o">=</span>10  --number-of-queries<span class="o">=</span>1000 --pre-query<span class="o">=</span><span class="s2">"truncate table test.pt_range;"</span> --query<span class="o">=</span><span class="s2">"insert into test.pt_range (some_data, createdAt, modifiedAt) select 'some_data',DATE_ADD(now(),INTERVAL round(rand() *150) DAY), now() from information_schema.tables a ,  information_schema.tables b limit 1000;"</span>  --socket<span class="o">=</span>/tmp/mysql_sandbox5719.sock -umsandbox -pmsandbox
date
<span class="nb">echo</span> <span class="s2">"========================================================"</span>
<span class="nb">echo</span> <span class="s2">"Test for insert on range column partition table"</span>
date
/MySQL_bianries/5.7.19/bin/mysqlslap  --concurrency<span class="o">=</span>10 --create-schema<span class="o">=</span><span class="nb">test</span> --iterations<span class="o">=</span>10  --number-of-queries<span class="o">=</span>1000 --pre-query<span class="o">=</span><span class="s2">"truncate table test.pt_range_columns;"</span> --query<span class="o">=</span><span class="s2">"insert into pt_range_columns (some_data, createdAt, modifiedAt) select 'some_data',DATE_ADD(now(),INTERVAL round(rand() *150) DAY), now() from information_schema.tables a ,  information_schema.tables b limit 1000;"</span>  --socket<span class="o">=</span>/tmp/mysql_sandbox5719.sock -umsandbox -pmsandbox
date
<span class="nb">echo</span> <span class="s2">"========================================================"</span>

<span class="o">[</span>root@localhost msb_5_7_19]# ./bt.sh &gt; x
<span class="o">[</span>root@localhost msb_5_7_19]# cat x
<span class="o">========================================================</span>
Test <span class="k">for </span>insert on range partition table
Sun Jan 14 06:50:06 EST 2018
Benchmark
        Average number of seconds to run all queries: 19.477 seconds
        Minimum number of seconds to run all queries: 18.528 seconds
        Maximum number of seconds to run all queries: 20.999 seconds
        Number of clients running queries: 10
        Average number of queries per client: 100

Sun Jan 14 06:53:23 EST 2018
<span class="o">========================================================</span>
Test <span class="k">for </span>insert on range column partition table
Sun Jan 14 06:53:23 EST 2018
Benchmark
        Average number of seconds to run all queries: 20.407 seconds
        Minimum number of seconds to run all queries: 18.257 seconds
        Maximum number of seconds to run all queries: 23.298 seconds
        Number of clients running queries: 10
        Average number of queries per client: 100

Sun Jan 14 06:56:49 EST 2018
<span class="o">========================================================</span>
</code></pre>
</div>

<p><strong><em>크게 차이는 없지만, range partition table 에 데이터를 넣는것 (평균 19.477 vs 20.407) 이 insert 단위 테스트에서는 조금 더 빠른 결과를 보여준다. (큰 차이는 없었다)</em></strong></p>

<ul>
  <li>조건을 통해 partition pruning 을 할 경우 (정확히는 여러달에 걸친 조건 ( between ‘2018-03-30’ and ‘2018-04-02’;)) , 의도치 않게 “RANGE (to_days(createdAt))” 에서 첫번째 partition 을 추가로 읽을 수 있다. 이는 여러달에 걸친 data 를 조회할때는 추가적인 scan (첫번째 partiton 에 대한 scan) 이 필요함으로 성능이 떨어진다.</li>
</ul>

<div class="language-sql highlighter-rouge"><pre class="highlight"><code><span class="n">mysql</span> <span class="p">[</span><span class="n">localhost</span><span class="p">]</span> <span class="err">{</span><span class="n">msandbox</span><span class="err">}</span> <span class="p">(</span><span class="n">test</span><span class="p">)</span> <span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">from</span> <span class="n">pt_range</span> <span class="k">where</span> <span class="n">createdAt</span> <span class="k">between</span> <span class="s1">'2018-03-30 00:00:00'</span> <span class="k">and</span> <span class="s1">'2018-04-30 00:00:00'</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+----------+-------------------------+-------+---------------+---------+---------+------+--------+----------+--------------------------+</span>
<span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span>    <span class="o">|</span> <span class="n">partitions</span>              <span class="o">|</span> <span class="k">type</span>  <span class="o">|</span> <span class="n">possible_keys</span> <span class="o">|</span> <span class="k">key</span>     <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="k">rows</span>   <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span>                    <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+----------+-------------------------+-------+---------------+---------+---------+------+--------+----------+--------------------------+</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">pt_range</span> <span class="o">|</span> <span class="n">p201801</span><span class="p">,</span><span class="n">p201803</span><span class="p">,</span><span class="n">p201804</span> <span class="o">|</span> <span class="k">index</span> <span class="o">|</span> <span class="k">NULL</span>          <span class="o">|</span> <span class="k">PRIMARY</span> <span class="o">|</span> <span class="mi">12</span>      <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="mi">524254</span> <span class="o">|</span>    <span class="mi">11</span><span class="p">.</span><span class="mi">11</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">where</span><span class="p">;</span> <span class="k">Using</span> <span class="k">index</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+----------+-------------------------+-------+---------------+---------+---------+------+--------+----------+--------------------------+</span>
<span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">09</span> <span class="n">sec</span><span class="p">)</span>

    <span class="c1">-- range partition 의 경우, createdAt between '2018-03-30 00:00:00' and '2018-04-30 00:00:00'; 시에 알 수 없는 p201801 에 대한 partition 을 scan 하게 된다.</span>


<span class="n">mysql</span> <span class="p">[</span><span class="n">localhost</span><span class="p">]</span> <span class="err">{</span><span class="n">msandbox</span><span class="err">}</span> <span class="p">(</span><span class="n">test</span><span class="p">)</span> <span class="o">&gt;</span> <span class="k">explain</span> <span class="k">select</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">from</span> <span class="n">pt_range_columns</span> <span class="k">where</span> <span class="n">createdAt</span> <span class="k">between</span> <span class="s1">'2018-03-30 00:00:00'</span> <span class="k">and</span>  <span class="s1">'2018-04-30 00:00:00'</span><span class="p">;</span>
<span class="o">+</span><span class="c1">----+-------------+------------------+-----------------+-------+---------------+---------+---------+------+--------+----------+--------------------------+</span>
<span class="o">|</span> <span class="n">id</span> <span class="o">|</span> <span class="n">select_type</span> <span class="o">|</span> <span class="k">table</span>            <span class="o">|</span> <span class="n">partitions</span>      <span class="o">|</span> <span class="k">type</span>  <span class="o">|</span> <span class="n">possible_keys</span> <span class="o">|</span> <span class="k">key</span>     <span class="o">|</span> <span class="n">key_len</span> <span class="o">|</span> <span class="k">ref</span>  <span class="o">|</span> <span class="k">rows</span>   <span class="o">|</span> <span class="n">filtered</span> <span class="o">|</span> <span class="n">Extra</span>                    <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+------------------+-----------------+-------+---------------+---------+---------+------+--------+----------+--------------------------+</span>
<span class="o">|</span>  <span class="mi">1</span> <span class="o">|</span> <span class="k">SIMPLE</span>      <span class="o">|</span> <span class="n">pt_range_columns</span> <span class="o">|</span> <span class="n">p201803</span><span class="p">,</span><span class="n">p201804</span> <span class="o">|</span> <span class="k">index</span> <span class="o">|</span> <span class="k">NULL</span>          <span class="o">|</span> <span class="k">PRIMARY</span> <span class="o">|</span> <span class="mi">12</span>      <span class="o">|</span> <span class="k">NULL</span> <span class="o">|</span> <span class="mi">406717</span> <span class="o">|</span>    <span class="mi">11</span><span class="p">.</span><span class="mi">11</span> <span class="o">|</span> <span class="k">Using</span> <span class="k">where</span><span class="p">;</span> <span class="k">Using</span> <span class="k">index</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">----+-------------+------------------+-----------------+-------+---------------+---------+---------+------+--------+----------+--------------------------+</span>
<span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

    <span class="c1">-- range columns partition 의 경우,  p201801 에 대한 partition 을 읽지 않는다.</span>
</code></pre>
</div>

<p><strong>이는 to_days 가 특정일짜에 대해서 null 을 return 할 수 있기때문에, null 이 저장된 첫번째 partition 을 읽어야 정확한 데이터를 추출해낼 수 있기 때문이다. 이는 bug 가 아닌 의도된 결과이다.</strong></p>

<p>예를 들어, ‘2018-04-00 00:00:00’ 의 경우, 데이터는 들어갈 수 있지만 (sql_mode 에 따라 다르지만, NO_ZERO_IN_DATE 를 사용하지 않는 경우 들어갈 수 있다.) 해당 결과는 to_days function 에의해 null 로 return 되어 첫번째 partition 에 저장되기 때문이다.</p>

<p>이를 createdAt between ‘2018-03-30 00:00:00’ and ‘2018-04-30 00:00:00’ 와 같은 조건으로 검색할 경우, ‘2018-04-00 00:00:00’ 도 맞는 조건임으로 뽑아내야 하며, 이를 위해 첫번째 partition이 검색되어야 한다.</p>

<p>하지만, 일반적으로 createdAt between ‘2018-04-01 00:00:00’ and ‘2018-04-30 23:59:59’ 와 같이 한달을 기준으로 혹은 더 작은 단위로 사용될 경우, 첫번째 partition 은 검색되지 않는다.</p>

<p>아래의 예제를 확인해보자.</p>

<div class="language-sql highlighter-rouge"><pre class="highlight"><code><span class="n">mysql</span> <span class="p">[</span><span class="n">localhost</span><span class="p">]</span> <span class="err">{</span><span class="n">msandbox</span><span class="err">}</span> <span class="p">(</span><span class="n">test</span><span class="p">)</span> <span class="o">&gt;</span> <span class="k">select</span> <span class="n">to_days</span><span class="p">(</span><span class="s1">'2018-04-00 00:00:00'</span><span class="p">);</span>
<span class="o">+</span><span class="c1">--------------------------------+</span>
<span class="o">|</span> <span class="n">to_days</span><span class="p">(</span><span class="s1">'2018-04-00 00:00:00'</span><span class="p">)</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">--------------------------------+</span>
<span class="o">|</span>                           <span class="k">NULL</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">--------------------------------+</span>
<span class="mi">1</span> <span class="k">row</span> <span class="k">in</span> <span class="k">set</span><span class="p">,</span> <span class="mi">1</span> <span class="n">warning</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span> <span class="n">sec</span><span class="p">)</span>

    <span class="c1">-- NULL 이 return 된다. to_days 로 표현할 수 없는 값이기 때문이다.</span>

<span class="n">mysql</span> <span class="p">[</span><span class="n">localhost</span><span class="p">]</span> <span class="err">{</span><span class="n">msandbox</span><span class="err">}</span> <span class="p">(</span><span class="n">test</span><span class="p">)</span> <span class="o">&gt;</span> <span class="k">insert</span> <span class="k">into</span> <span class="n">pt_range</span> <span class="p">(</span><span class="n">some_data</span><span class="p">,</span> <span class="n">createdAt</span><span class="p">,</span> <span class="n">modifiedAt</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="s1">'some_data'</span><span class="p">,</span><span class="s1">'2018-04-00 00:00:00'</span><span class="mi">0</span><span class="s1">',now());
ERROR 1292 (22007): Incorrect datetime value: '</span><span class="mi">2018</span><span class="o">-</span><span class="mi">04</span><span class="o">-</span><span class="mi">00</span> <span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="s1">' for column '</span><span class="n">createdAt</span><span class="s1">' at row 1

mysql [localhost] {msandbox} (test) &gt; select @@session.sql_mode;
+-------------------------------------------------------------------------------------------------------------------------------------------+
| @@session.sql_mode                                                                                                                        |
+-------------------------------------------------------------------------------------------------------------------------------------------+
| ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION |
+-------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.00 sec)

    -- 해당 값으로 data 를 넣으면 5.7 에서는 error 가 발생한다. 그 이유는 5.7 의 default sql_mode 값으로 NO_ZERO_IN_DATE 값을 포함하기 때문이다.


mysql [localhost] {msandbox} (test) &gt; SET SESSION sql_mode = sys.list_drop(@@session.sql_mode, '</span><span class="n">NO_ZERO_IN_DATE</span><span class="s1">');
Query OK, 0 rows affected, 1 warning (0.00 sec)

mysql [localhost] {msandbox} (test) &gt; select @@session.sql_mode;
+---------------------------------------------------------------------------------------------------------------------------+
| @@session.sql_mode                                                                                                        |
+---------------------------------------------------------------------------------------------------------------------------+
| ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION |
+---------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.00 sec)

    --  sys.list_drop() 을 이용하여, 해당 session 의 sql_mode 에서 NO_ZERO_IN_DATE 값을 제거하였다.


mysql [localhost] {msandbox} (test) &gt; insert into pt_range (some_data, createdAt, modifiedAt) values ('</span><span class="n">some_data</span><span class="s1">','</span><span class="mi">2018</span><span class="o">-</span><span class="mi">04</span><span class="o">-</span><span class="mi">00</span> <span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="s1">',now());
Query OK, 1 row affected (0.01 sec)

    --  값이 잘 들어간다. 5.6 의 경우, sql_mode 의 default 값에 NO_ZERO_IN_DATE 가 존재하지 않음으로 위의 작업 없이도 테스트가 가능하다.


mysql [localhost] {msandbox} (test) &gt; explain select * from pt_range where createdAt='</span><span class="mi">2018</span><span class="o">-</span><span class="mi">04</span><span class="o">-</span><span class="mi">00</span> <span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="s1">';
+----+-------------+----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
| id | select_type | table    | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | pt_range | p201801    | ALL  | NULL          | NULL | NULL    | NULL | 107694 |    10.00 | Using where |
+----+-------------+----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

    --  실행계획을 range partition 의 경우,  partition pruning 시에 p201801 를 읽는것이 확인된다.


mysql [localhost] {msandbox} (test) &gt; select * from pt_range where createdAt='</span><span class="mi">2018</span><span class="o">-</span><span class="mi">04</span><span class="o">-</span><span class="mi">00</span> <span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="s1">';
+---------+-----------+----------------------------+----------------------------+
| id      | some_data | createdAt                  | modifiedAt                 |
+---------+-----------+----------------------------+----------------------------+
| 1002002 | some_data | 2018-04-00 00:00:00.000000 | 2018-01-14 07:09:52.000000 |
+---------+-----------+----------------------------+----------------------------+
1 row in set (0.09 sec)

    --  원하는값도 정상적으로 가져온다.


mysql [localhost] {msandbox} (test) &gt; insert into pt_range_columns (some_data, createdAt, modifiedAt) values ('</span><span class="n">some_data</span><span class="s1">','</span><span class="mi">2018</span><span class="o">-</span><span class="mi">04</span><span class="o">-</span><span class="mi">00</span> <span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="s1">',now());
Query OK, 1 row affected (0.01 sec)

mysql [localhost] {msandbox} (test) &gt; explain select * from pt_range_columns where createdAt='</span><span class="mi">2018</span><span class="o">-</span><span class="mi">04</span><span class="o">-</span><span class="mi">00</span> <span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="s1">';
+----+-------------+------------------+------------+------+---------------+------+---------+------+--------+----------+-------------+
| id | select_type | table            | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+------------------+------------+------+---------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | pt_range_columns | p201803    | ALL  | NULL          | NULL | NULL    | NULL | 206671 |    10.00 | Using where |
+----+-------------+------------------+------------+------+---------------+------+---------+------+--------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

    --  실행계획을 range columns partition 의 경우, 기대한것처럼 partition pruning 시에 p201803 를 읽는것이 확인된다.


mysql [localhost] {msandbox} (test) &gt; select * from pt_range_columns where createdAt='</span><span class="mi">2018</span><span class="o">-</span><span class="mi">04</span><span class="o">-</span><span class="mi">00</span> <span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="p">:</span><span class="mi">00</span><span class="s1">';
+---------+-----------+----------------------------+----------------------------+
| id      | some_data | createdAt                  | modifiedAt                 |
+---------+-----------+----------------------------+----------------------------+
| 1002278 | some_data | 2018-04-00 00:00:00.000000 | 2018-01-14 07:11:15.000000 |
+---------+-----------+----------------------------+----------------------------+
1 row in set (0.13 sec)

mysql [localhost] {msandbox} (test) &gt; SET SESSION sql_mode = sys.list_add(@@session.sql_mode, '</span><span class="n">NO_ZERO_IN_DATE</span><span class="s1">');
Query OK, 0 rows affected (0.00 sec)

mysql [localhost] {msandbox} (test) &gt; select @@session.sql_mode;
+-------------------------------------------------------------------------------------------------------------------------------------------+
| @@session.sql_mode                                                                                                                        |
+-------------------------------------------------------------------------------------------------------------------------------------------+
| ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION |
+-------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.00 sec)

    -- sys.list_add() 을 이용하여 다시 원래대로 세션의 sql_mode  값에 NO_ZERO_IN_DATE 를 추가할 수 있다.
</span></code></pre>
</div>

<ul>
  <li>이에대해 관련된 공식 문서와 버그는 아래와 같다.</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>- http://bugs.mysql.com/bug.php?id=72383 (Pruning includes first partition when query range crosses month boundary)
- Bug 18621754 : PRUNING INCLUDES FIRST PARTITION WHEN QUERY RANGE CROSSES MONTH BOUNDARY


    Fixed in 5.1+, documented in the 5.1.69, 5.5.31, 5.6.11, and 5.7.1 changelogs


    A query on a table partitioned by range and using TO_DAYS() as a
    partitioing function always included the first partition of the
    table when pruning. This happened regardless of the range
    employed in the BETWEEN clause of such a query.

    - https://dev.mysql.com/doc/relnotes/mysql/5.5/en/news-5-5-31.html
    - https://dev.mysql.com/doc/relnotes/mysql/5.6/en/news-5-6-11.html
</code></pre>
</div>

<p>추가로, range columns 에서 pruning 이 정확히 안되는 버그가 있었지만, 이는 5-5-33 과 5-6-13 에서 fix 되었다.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>- Bug 16447483 : PARTITION PRUNING IS NOT CORRECT FOR RANGE COLUMNS

    - https://dev.mysql.com/doc/relnotes/mysql/5.5/en/news-5-5-33.html
    - https://dev.mysql.com/doc/relnotes/mysql/5.6/en/news-5-6-13.html
</code></pre>
</div>

<h4 id="2-가독성-및-관리관점에서">2. 가독성 및 관리관점에서,</h4>
<p>가독성 부분에서는 “PARTITION BY RANGE COLUMNS(createdAt)” 이 더 좋을 수 있다. show create table 등으로 확인할때 직관적으로 날짜를 확인하여 파티션구조를 확인할 수 있기 때문이다.</p>

<div class="language-sql highlighter-rouge"><pre class="highlight"><code><span class="p">...</span>
<span class="cm">/*!50500 PARTITION BY RANGE  COLUMNS(createdAt)
(PARTITION p201801 VALUES LESS THAN ('2018-02-01') ENGINE = InnoDB,
 PARTITION p201802 VALUES LESS THAN ('2018-03-01') ENGINE = InnoDB,
 PARTITION p201803 VALUES LESS THAN ('2018-04-01') ENGINE = InnoDB,
 PARTITION p201804 VALUES LESS THAN ('2018-05-01') ENGINE = InnoDB,
 PARTITION p201805 VALUES LESS THAN ('2018-06-01') ENGINE = InnoDB,
 PARTITION p201806 VALUES LESS THAN ('2018-07-01') ENGINE = InnoDB) */</span>
<span class="err">반면에</span> <span class="err">“</span><span class="n">PARTITION</span> <span class="k">BY</span> <span class="n">RANGE</span> <span class="p">(</span><span class="n">to_days</span><span class="p">(</span><span class="n">createdAt</span><span class="p">))</span><span class="err">”</span> <span class="err">의</span> <span class="err">경우</span><span class="p">,</span> <span class="k">show</span> <span class="k">create</span> <span class="k">table</span> <span class="err">시</span> <span class="n">to_days</span><span class="p">(</span><span class="err">‘</span><span class="mi">2018</span><span class="o">-</span><span class="mi">02</span><span class="o">-</span><span class="mi">01</span><span class="err">’</span><span class="p">)</span> <span class="err">가</span> <span class="err">변환되어</span> <span class="mi">737091</span> <span class="err">라는</span> <span class="err">결과가</span> <span class="err">반환된다</span><span class="p">.</span> <span class="err">이는</span> <span class="err">가독성</span> <span class="err">부분에서</span> <span class="err">많이</span> <span class="err">떨어질뿐</span> <span class="err">아니라</span><span class="p">,</span> <span class="err">향후</span> <span class="n">partition</span> <span class="err">을</span> <span class="err">추가할때도</span> <span class="k">SELECT</span> <span class="n">DATE_ADD</span><span class="p">(</span><span class="err">‘</span><span class="mi">0000</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">01</span><span class="err">’</span><span class="p">,</span> <span class="n">INTERVAL</span> <span class="mi">737241</span><span class="o">-</span><span class="mi">1</span> <span class="k">DAY</span><span class="p">);</span> <span class="err">와</span> <span class="err">같이</span> <span class="err">언제까지</span> <span class="n">partition</span> <span class="err">을</span> <span class="err">추가했는지</span> <span class="err">알아내야한다</span><span class="p">.</span>

<span class="p">...</span>
<span class="cm">/*!50100 PARTITION BY RANGE (to_days(createdAt))
(PARTITION p201801 VALUES LESS THAN (737091) ENGINE = InnoDB,
 PARTITION p201802 VALUES LESS THAN (737119) ENGINE = InnoDB,
 PARTITION p201803 VALUES LESS THAN (737150) ENGINE = InnoDB,
 PARTITION p201804 VALUES LESS THAN (737180) ENGINE = InnoDB,
 PARTITION p201805 VALUES LESS THAN (737211) ENGINE = InnoDB,
 PARTITION p201806 VALUES LESS THAN (737241) ENGINE = InnoDB) */</span>
</code></pre>
</div>

<h3 id="결론">결론</h3>
<p>일반적으로, 달이 넘어가는 데이터를 조회하지 않는 경우, “PARTITION BY RANGE COLUMNS(createdAt)” 과 “PARTITION BY RANGE (to_days(createdAt))” 는 성능에 큰 영향을 주지 않는다.</p>

<p>하지만, 달이 넘어가는 데이터를 조회하는 경우는 꼭 explain 을 확인해보자. 만약 첫번째 partition 이 데이터가 많은 경우, 이는 overhead 가 될 수 있다.</p>

<p>또한 partition drop 시 invalid date 를 가진 data 가 의도치않게 날아가버릴 수도 있다. 예를 들면, 첫번째 partition 인 2월이전의 partition 을 drop 하고 싶었지만, ‘2018-04-00 00:00:00’ row 도 함께 삭제될 수 있다.</p>

<p>RANGE partiton 을 꼭 써야만한다면, 아래와 같이 첫번째 partition 을 추가하는것이 좋다. 첫번째 partition 을 확인하더라도 첫번째 파티션에 저장된 유효하지 않은 데이터만 확인함으로 성능상 유리할 수 있다.</p>

<div class="language-sql highlighter-rouge"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">pt_range</span> <span class="p">(</span>
  <span class="n">id</span> <span class="n">int</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
  <span class="n">some_data</span> <span class="n">varchar</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span>
  <span class="n">createdAt</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">modifiedAt</span> <span class="n">datetime</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span><span class="n">createdAt</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="n">AUTO_INCREMENT</span><span class="o">=</span><span class="mi">1</span> <span class="k">DEFAULT</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">utf8</span>
<span class="n">partition</span> <span class="k">by</span> <span class="n">range</span> <span class="p">(</span><span class="n">to_days</span><span class="p">(</span><span class="n">createdAt</span><span class="p">))</span>
<span class="p">(</span><span class="n">PARTITION</span> <span class="n">INVALID_DATE_DATA</span> <span class="k">VALUES</span> <span class="k">LESS</span> <span class="k">THAN</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="n">ENGINE</span> <span class="o">=</span> <span class="n">InnoDB</span><span class="p">,</span>
 <span class="n">PARTITION</span> <span class="n">p201801</span> <span class="k">VALUES</span> <span class="k">LESS</span> <span class="k">THAN</span> <span class="p">(</span><span class="mi">737091</span><span class="p">)</span> <span class="n">ENGINE</span> <span class="o">=</span> <span class="n">InnoDB</span><span class="p">,</span>
 <span class="n">PARTITION</span> <span class="n">p201802</span> <span class="k">VALUES</span> <span class="k">LESS</span> <span class="k">THAN</span> <span class="p">(</span><span class="mi">737119</span><span class="p">)</span> <span class="n">ENGINE</span> <span class="o">=</span> <span class="n">InnoDB</span><span class="p">,</span>
 <span class="n">PARTITION</span> <span class="n">p201803</span> <span class="k">VALUES</span> <span class="k">LESS</span> <span class="k">THAN</span> <span class="p">(</span><span class="mi">737150</span><span class="p">)</span> <span class="n">ENGINE</span> <span class="o">=</span> <span class="n">InnoDB</span><span class="p">,</span>
 <span class="n">PARTITION</span> <span class="n">p201804</span> <span class="k">VALUES</span> <span class="k">LESS</span> <span class="k">THAN</span> <span class="p">(</span><span class="mi">737180</span><span class="p">)</span> <span class="n">ENGINE</span> <span class="o">=</span> <span class="n">InnoDB</span><span class="p">,</span>
 <span class="n">PARTITION</span> <span class="n">p201805</span> <span class="k">VALUES</span> <span class="k">LESS</span> <span class="k">THAN</span> <span class="p">(</span><span class="mi">737211</span><span class="p">)</span> <span class="n">ENGINE</span> <span class="o">=</span> <span class="n">InnoDB</span><span class="p">,</span>
 <span class="n">PARTITION</span> <span class="n">p201806</span> <span class="k">VALUES</span> <span class="k">LESS</span> <span class="k">THAN</span> <span class="p">(</span><span class="mi">737241</span><span class="p">)</span> <span class="n">ENGINE</span> <span class="o">=</span> <span class="n">InnoDB</span><span class="p">);</span>
</code></pre>
</div>

        
          <div id="disqus_thread"></div><!-- /#disqus_thread -->
          
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'minsql'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = 'https://' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

        
      </div><!-- /.entry-content -->
    </div><!-- /.entry-wrapper -->
    <nav class="pagination" role="navigation">
      
        <a href="http://localhost:4000/blog/MySQL-sandbox-%EC%84%A4%EC%B9%98%EC%99%80-%EC%9D%B4%EC%9A%A9%EB%B0%A9%EB%B2%95/" class="btn" title="MySQL sandbox 설치와 이용방법">Previous</a>
      
      
    </nav><!-- /.pagination -->
  </article>
</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo" class="entry-wrapper">
    

<span>&copy; 2018 MINSQL<!--. Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using the <a href="https://mademistakes.com/work/so-simple-jekyll-theme/" rel="nofollow">So Simple Theme</a>.--></span>
<div class="social-icons">
	
	
	
	
	
	
	
	
	
  
	
  <a href="http://localhost:4000/feed.xml" title="Atom/RSS feed"><i class="fa fa-rss-square fa-2x"></i></a>
</div><!-- /.social-icons -->

  </footer>
</div><!-- /.footer-wrapper -->

<script type="text/javascript">
  var BASE_URL = 'http://localhost:4000';
</script>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>




</body>
</html>
